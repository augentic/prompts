# qwasr BUSINESS LOGIC CRATE CONSTRUCTION

## LEGACY SOURCE CODE TO ANALYZE (injected)
${LEGACY_CODE}

---

## OUTPUT TARGET

- Write the generated Rust crate to #file:${GENERATED_CRATE}/ (create the directory if missing).
- Preserve the canonical crate layout: src/, tests/, data/, docs/, Cargo.toml.
- Overwrite existing files in that folder with freshly generated code.

---

## ROLE

Principal Rust Engineer specializing in IR-driven TypeScript→Rust migration for the **qwasr runtime**, focusing on **business logic crates only** (domain modules + provider trait composition). The qwasr runtime uses proc macros for guest/host wiring; this prompt governs domain code generation.

**Core principles:** Strong typing, capability separation, deterministic execution, zero inference, zero global state, zero unapproved capabilities, wasm32 compatibility.

---

## SECTION 1 — INPUT HIERARCHY

**Priority order:**
1. **IR** — Absolute truth for behavior, control flow, validation. Location: #file:${IR_FILE}
2. **TS_SOURCE** — Naming and context only. Line-by-line translation forbidden. Location: #file:${LEGACY_CODE}
3. **OUTPUT_EXAMPLE** — Definitive pattern for structure, formatting, conventions.
4. **qwasr_RUNTIME_DOCS** — Reference: `migration-pipeline/qwasr-runtime/docs/` within this repo (access via MCP server as in base prompt).
5. **PROVIDER_INTERFACE_SUMMARY** — External provider traits. Import only, never redefine. (via github Context MCP)

**Architecture & qwasr Guidance:**
Found within the github Context MCP
- See `supportingDocs/overview.md` for the qwasr model.
- See `supportingDocs/provider-composition.md` for provider patterns.
- See `supportingDocs/wasm32-constraints.md` for wasm32 rules.
- See `supportingDocs/guardrails.md` for enforceable guardrails and hard rules.
- See `supportingDocs/ms-pragmatic-rust.txt` for a guideline on coding style for idiomatic Rust that must be followed.

**Scope:** This prompt governs **business logic crates only**. Guest/host wiring is handled by `qwasr_sdk::guest!` and `qwasr::runtime!` macros (not generated by prompts).

**Resolution:** Logic: IR > TS > NONE | Naming: TS > IR | Architecture: OUTPUT_EXAMPLE > IR > TS

---

## SECTION 2 — qwasr RUNTIME MODEL

### 2.1 What is qwasr?

qwasr is a standardised WASM component runtime that replaces WRT. It uses **proc macros** to eliminate boilerplate:

- **`qwasr::runtime!`** — Constructs the host/runtime (in `examples/`). Not generated by prompts.
- **`qwasr_sdk::guest!`** — Declares guest interfaces (HTTP routes, messaging topics) in `src/guest.rs`. Not generated by prompts.
- **Business logic crates** — Pure domain code with no WASI imports. **This is what you generate.**

### 2.2 Scope: Business Logic Crates Only

Your job is to generate **business logic crates** — pure domain code with no WASI imports.

**NOT your job:**
- Guest/host wiring (handled by `qwasr_sdk::guest!` and `qwasr::runtime!` macros)
- HTTP/messaging handlers (hand-written by component owner)
- Provider trait implementations (hand-written by component owner)
- Runtime construction (handled by `qwasr::runtime!` macro)

See `supportingDocs/overview.md` for the full architectural model.

### 2.3 What Prompts Generate vs What Macros Handle

| Artifact | Generated by | Scope |
|----------|--------------|-------|
| Business logic crate | **This prompt** | Domain modules, types, error handling, logic |
| Guest interface (`src/guest.rs`) | `qwasr_sdk::guest!` macro | HTTP routes, messaging topics |
| HTTP handlers (`src/http.rs`) | Manual (not prompt) | Axum routes, request parsing |
| Messaging handlers (`src/messaging.rs`) | Manual (not prompt) | Topic routing, message parsing |
| Provider impl (`src/provider.rs`) | Manual (not prompt) | WASI trait implementations |
| Host runtime (`examples/<component>.rs`) | `qwasr::runtime!` macro | Runtime construction, WASI wiring |

**Key:** Prompts generate **domain logic only**. Everything else is either macro-generated or hand-written by the component owner.

### 2.4 Handler Layer Integration

When business logic requires HTTP or messaging handlers, follow this pattern:

**Handler Trait Pattern:**
```rust
use qwasr_sdk::api::{Handler, Context, Reply};
use qwasr_sdk::{Config, HttpRequest, StateStore, Result, IntoBody};

// Implement Handler<P> directly on the request type
impl<P> Handler<P> for MyRequest 
where 
    P: Config + HttpRequest + StateStore 
{
    type Input = Self;
    type Output = MyResponse;
    type Error = qwasr_sdk::Error;
    
    fn from_input(input: Self::Input) -> Result<Self> {
        Ok(input)
    }
    
    async fn handle(self, ctx: Context<'_, P>) -> Result<Reply<Self::Output>> {
        // Delegate to domain logic, passing provider reference
        let result = my_domain_logic(&ctx.provider, self.param).await?;
        Ok(Reply::from(MyResponse { result }))
    }
}
```

**Key rules:**
- Implement `Handler<P>` directly on request type (not wrapper types)
- Use `Context<'_, P>` to access provider via `ctx.provider`
- Return `Reply<T>` wrapped responses using `.into()` or `Reply::from()`
- Response types must implement `IntoBody` for serialization
- **Delegate to domain logic** — handler should be thin, calling separate async functions
- Generic constraints specify only required traits: `P: Config + HttpRequest + ...`
- Never redefine `Handler`, `Context`, `Reply`, or `IntoBody` traits

**Separation of concerns:**
- Handler layer (`src/handler.rs`) — Thin adapter, validates input, calls domain logic
- Domain logic (`src/logic/`) — Pure business logic, accepts generic provider `&P`
- Provider layer (`src/provider.rs`) — WASI trait implementations (manual, not generated)

See `supportingDocs/handler-trait-patterns.md` for detailed handler examples.

---

## SECTION 3 — PROVIDER PATTERN (qwasr-ALIGNED)

### 3.1 Canonical WASI Families

| Family | WASI Binding | Purpose |
|--------|--------------|---------|
| http | `wasi_http` | Outbound HTTP requests |
| messaging | `wasi_messaging` | Kafka/message broker |
| kv | `wasi_keyvalue` | Distributed cache (Redis) |
| identity | `wasi_identity` | Authentication (Azure AD) |
| telemetry | `wasi_otel` | OpenTelemetry observability |
| config | `wasi_config` | Runtime configuration |

**Do NOT invent additional families.** Use TODO markers for unsupported capabilities.

### 3.2 Provider Traits (from qwasr_sdk)

The canonical provider traits are:
- **Config** — Read runtime configuration
- **HttpRequest** — Make outbound HTTP calls
- **Publisher** — Publish to message topics
- **StateStore** — Cache/KV operations
- **Identity** — Get authentication tokens

**Import from `qwasr_sdk`, never redefine.**

See `supportingDocs/provider-composition.md` for trait signatures and detailed documentation.

### 3.3 Provider Rules

- Domain code uses traits only — never imports `wasi_*` directly
- No host libraries: `reqwest`, `hyper`, `redis`, `kafka`
- Provider constructed at handler boundary only (in `src/provider.rs` or `src/http.rs`)
- No global/static state
- Compose only the traits required by your crate

### 3.4 Provider Composition Patterns

See `qwasr-runtime/docs/code-patterns.md` for concrete examples:
- Minimal provider (Config + HttpRequest)
- Full provider (Config + HttpRequest + StateStore + Publisher)
- Provider with identity (Config + HttpRequest + Identity)

**Rule:** Compose only the traits required by your crate. Specify exact trait bounds in function signatures.

### 3.5 TODO Markers

```rust
// TODO: [UNSUPPORTED_PROVIDER] <desc>
// TODO: [PROVIDER_CAPABILITY_MISSING] <desc>
```

---

## SECTION 4 — WASM32 CONSTRAINTS (CRITICAL)

**Every generated crate MUST pass the validation checklist at the end of this section.**

**Wasm32 is a sandboxed environment. No direct OS access.**

### 4.1 Forbidden OS APIs

| Module | Why | Alternative |
|--------|-----|-------------|
| `std::fs` | No filesystem | Use provider trait or TODO |
| `std::net` | No raw networking | Use `HttpRequest` provider trait |
| `std::thread` | No threading | Use async/await with `tokio` |
| `std::process` | No subprocess | Not applicable |
| `std::time::SystemTime` | No direct wall-clock | Use `chrono::Utc::now()` |
| `std::env` | No OS env access | Use `Config` provider trait |

### 4.2 Wasm32 Rules

- **Configuration:** Use `Config::get()` provider trait, never `std::env::var()`
- **Time:** Use `chrono::Utc::now()`, never `SystemTime::now()`
- **Async:** All I/O must be async. No blocking operations.
- **Numeric precision:** Prefer `f32` over `f64` for wasm32 efficiency (when precision allows)

See `qwasr-runtime/docs/wasm32-constraints.md` for detailed rules and concrete examples.

---

## SECTION 5 — I/O MAPPING (1-TO-1)

| TypeScript | Rust Provider |
|------------|---------------|
| `fetch`, `axios.*` | `HttpRequest::fetch()` |
| `producer.send` | `Publisher::send()` |
| `consumer.on("message")` | Handled by guest macro (not domain code) |
| `redis.get/set/del` | `StateStore::get/set/delete()` |
| `moment()`, `Date.now()` | `chrono::Utc::now()` |
| `moment.tz()` | `DateTime::with_timezone()` (chrono-tz) |
| Azure AD token | `Identity::access_token()` |
| Environment variables | `Config::get()` |

**Forbidden:** Retries, backoff, `SystemTime::now()` in domain.

---

## SECTION 6 — DEPENDENCY INJECTION

**Rule:** Call trait methods directly on provider. No unified `Provider` trait in domain code.

**Boundary separation:**
- Domain code (`src/logic/`, `src/handler.rs`) — NO WASI imports, uses provider traits only
- Provider code (`src/provider.rs`) — WASI imports allowed here only

See `qwasr-runtime/docs/code-patterns.md` for concrete provider composition examples.

---

## SECTION 7 — STATELESSNESS

**FORBIDDEN:**
- `static mut`, `OnceCell`, `LazyLock`, `lazy_static!`
- Global mutable collections
- In-memory caching/memoization
- Background tasks outliving handler

**ALLOWED:**
- `const` (compile-time immutable)
- `const fn`
- Immutable static references

**Caching rule:** Use `StateStore` provider trait only. No in-memory caches.

**Configuration rule:** Runtime config via `Config::get()`, compile-time constants via `const`.

See `qwasr-runtime/docs/code-patterns.md` for caching and configuration examples.

---

## SECTION 8 — STRONG TYPING

**Rules:**
- TypeScript unions → Rust enums
- Primitive IDs → Newtypes (not raw `String`)
- Avoid raw literals for states
- Avoid unnecessary `f64` (prefer `f32` where applicable)

See `qwasr-runtime/docs/code-patterns.md` for strong typing examples.

---

## SECTION 9 — ERROR HANDLING

**Rules:**
- Domain errors use `thiserror::Error` with strongly typed variants
- Handler layer uses `anyhow::Result` with `.context()` for error propagation
- All errors use `?` operator or `.context()`, no `unwrap()` in production

See `qwasr-runtime/docs/code-patterns.md` for error handling examples.

---

## SECTION 10 — TESTING

**Minimum coverage:**
- Core domain flows (unit tests) using mock providers
- At least one handler round-trip per major endpoint
- All major domain flows covered

See `qwasr-runtime/docs/code-patterns.md` for mock provider and test patterns.

---

## SECTION 11 — OUTPUT STRUCTURE

**Business logic crate layout:**
- `Cargo.toml` — Dependencies (anyhow, serde, chrono, thiserror, tokio, tracing, qwasr-sdk)
- `src/lib.rs` — Public API + re-exports (with `#![cfg(target_arch = "wasm32")]` guard)
- `src/error.rs` — Domain error types
- `src/types.rs` — Domain types
- `src/handler.rs` — Handler trait implementation (if applicable)
- `src/logic/` — Domain logic modules
- `tests/` — Unit tests with mock providers
- `data/` — Test fixtures

See `qwasr-runtime/docs/code-patterns.md` for directory structure and file organization examples.

---

## SECTION 12 — HARD RULES

**MUST:**
- Implement all IR logic exactly
- Use provider traits for all I/O
- Generate stateless, deterministic code
- Use `chrono` for time, `StateStore` for caching
- Match OUTPUT_EXAMPLE structure
- Treat provider interfaces as **authoritative** — import only, never redefine

**MUST NOT:**
- Simplify/remove IR behavior
- Hallucinate functionality
- Infer missing logic — use TODO markers
- Use global state or in-memory caching
- Import `wasi_*` in domain code
- Call `SystemTime::now()` or `std::env::var()` in domain
- Invent new provider families
- Implement guest/host wiring (that's the macro's job)

**Clarification Protocol:** Stop, request clarification, document ambiguity, wait.

---

## SECTION 13 — COMMON PITFALLS IN qwasr MIGRATION

See `qwasr-runtime/docs/code-patterns.md` for concrete do's and don'ts:

- **Importing wasi_* directly** — Use provider traits instead
- **Hardcoding configuration** — Use `Config::get()` provider trait
- **In-memory caching** — Use `StateStore` provider trait
- **Blocking operations** — Use async/await with `tokio`
- **Over-specified provider bounds** — Specify only traits you actually use

**Key principle:** Domain code must be provider-agnostic. All I/O goes through provider traits.

---

## SECTION 14 — VALIDATION CHECKLIST

Before submitting generated code, verify:

- [ ] **No forbidden OS APIs**
  - [ ] No `std::fs`, `std::net`, `std::thread`, `std::process`
  - [ ] No `std::env::var()` (use `Config::get()` instead)
  - [ ] No `SystemTime::now()` (use `chrono::Utc::now()` instead)

- [ ] **Provider traits only**
  - [ ] No `wasi_*` imports in domain code
  - [ ] All I/O goes through provider trait methods
  - [ ] Provider trait bounds match actual usage

- [ ] **Wasm32 compatibility**
  - [ ] All async operations use `.await`
  - [ ] No blocking calls (no `thread::sleep`, no `std::sync::Mutex`)
  - [ ] No global mutable state (`static mut`, `LazyLock`, etc.)
  - [ ] External caching only (via `StateStore`)

- [ ] **Error handling**
  - [ ] Domain errors use `thiserror::Error`
  - [ ] Handler layer uses `anyhow::Result`
  - [ ] All errors use `?` or `.context()`, no `unwrap()` in production

- [ ] **Strong typing**
  - [ ] IDs are newtypes, not raw `String`
  - [ ] Enums for state, not string literals
  - [ ] No unnecessary `f64` (prefer `f32` where applicable)

- [ ] **Statelessness**
  - [ ] No in-memory caches
  - [ ] No background tasks
  - [ ] Configuration via `Config::get()`, not `const`

- [ ] **Testing**
  - [ ] Mock provider for unit tests
  - [ ] At least one handler round-trip test
  - [ ] All major domain flows covered

- [ ] **Documentation**
  - [ ] Migration.md explains IR mapping
  - [ ] Architecture.md documents data flows
  - [ ] .env.example lists all config keys

---

## SECTION 15 — FORBIDDEN PATTERNS

| Category | Forbidden |
|----------|-----------|
| Domain | `wasi_*` imports, provider trait definitions, host libraries |
| State | `static mut`, `OnceCell`, `LazyLock`, global collections |
| Time | `SystemTime::now()`, `std::time::*` |
| Config | `std::env::var()`, hardcoded runtime values |
| Concurrency | threads, `tokio::spawn`, blocking ops |
| Networking | `std::net`, `reqwest`, `hyper` |
| Logging | business data at info/warn/error |
| Wiring | Guest/host boundary code (use macros) |

---

## SECTION 16 — POST-GENERATION DOCS

Generate **after** code completion:

1. **Migration.md** — Component migration summary, IR mapping, uncertainties, design choices
2. **Architecture.md** — Data flows, handler/provider interactions, error handling, statelessness
3. **.env.example** — All required environment variables

---

## SECTION 17 — REFERENCE DOCUMENTATION

**Always available for context:**


- `supportingDocs/overview.md` — qwasr runtime model and scope
- `supportingDocs/guest-macro.md` — Guest interface patterns
- `supportingDocs/provider-composition.md` — Provider trait patterns and signatures
- `supportingDocs/code-patterns.md` — Concrete code examples (do's and don'ts)
- `supportingDocs/handler-trait-patterns.md` — Handler trait patterns
- `supportingDocs/guardrails.md` — Enforceable guardrails and hard rules
- `supportingDocs/wasm32-constraints.md` — Wasm32 rules and gotchas
- `supportingDocs/build-and-deploy.md` — Build and deployment
- `supportingDocs/ms-pragmatic-rust` - Guidelines for idiomatic code style that must be followed

**When generating code:** Reference `supportingDocs/code-patterns.md` for concrete examples of provider composition, error handling, testing, and common pitfalls.

---