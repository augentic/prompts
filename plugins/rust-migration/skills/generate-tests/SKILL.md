---
name: generate-tests
description: Generate Replayer test harness for Rust WASM components using augentic-test framework with fixture-based testing.
argument-hint: [rust-crate-path]
---

# Generate Tests Skill

## Overview

Generate a comprehensive "Replayer" test harness for a Rust WASM component. This harness runs the component against recorded production data (snapshots) to verify behavior correctness, handling time-dependent logic and external I/O mocking.

---

## Arguments

1. **Rust Crate Path** (`$ARGUMENTS[0]`): Path to the generated Rust crate (from generate-crate skill)

---

## Required Permissions

⚠️ **RECOMMENDED**: For seamless execution, request `required_permissions: ["all"]` on the first Shell command to enable file generation and cargo test compilation without interruption.

---

## Prerequisites

- Rust crate generated by `generate-crate` skill
- Component source code at `$ARGUMENTS[0]/src/`
- Test data fixtures in `$ARGUMENTS[0]/data/replay/` (JSON files)

---

## Process

### Phase 1: Context Analysis

Before writing code, analyze the component:

1. **Input Type**: What struct does the component accept? (e.g., `R9kMessage`, `HttpRequest`)
2. **Output Type**: What does it produce? (e.g., `Vec<OutputEvent>`)
3. **Dependencies**: Does it use `Config`, `HttpRequest`, `Publisher`, `Identity`, `StateStore`?
4. **Time Sensitivity**: Does the component compare timestamps against "now"?

Read `$ARGUMENTS[0]/src/lib.rs` and handler files to identify these.

### Phase 2: Define the Replay Fixture

Create `$ARGUMENTS[0]/tests/provider.rs` implementing `augentic_test::Fixture`.

### Phase 3: Implement MockProvider

Create provider that captures side-effects and provides mocked responses.

### Phase 4: Time Transformation

Implement `shift_time` function if component has time-sensitive logic.

### Phase 5: Test Runner

Create `$ARGUMENTS[0]/tests/replay.rs` with test execution and verification.

---

## Fixture Trait (Exact Definition)

The `augentic_test::Fixture` trait MUST be implemented exactly:

```rust
pub trait Fixture: Sized + Clone {
    type Error: Clone;
    type Input: Clone;
    type Output: Clone;
    type TransformParams: Clone + Default;

    fn from_data(data_def: &TestDef<Self::Error>) -> Self;
    fn input(&self) -> Option<Self::Input>;
    fn params(&self) -> Option<Self::TransformParams>;
    fn output(&self) -> Option<Result<Self::Output, Self::Error>>;
}
```

**CRITICAL**: Do NOT create custom `TestFixture` struct. Implement the exact trait above.

---

## Generated Files

### tests/provider.rs

```rust
use augentic_test::{Fetcher, Fixture, PreparedTestCase, TestCase, TestDef, TestResult};
use qwasr_sdk::{api::Client, Config, HttpRequest, Identity, Publisher, Message, Error, Result};
use std::sync::{Arc, Mutex};
use anyhow::anyhow;

// Import component types
use crate::{ComponentInputType, ExpectedOutputType};

// ============================================
// Replay Fixture
// ============================================

#[derive(Debug, Clone)]
pub struct Replay {
    pub input: Option<ComponentInputType>,
    pub params: Option<ReplayTransform>,
    pub output: Option<ReplayOutput>,
}

#[derive(Debug, Clone, Default, serde::Deserialize)]
pub struct ReplayTransform {
    pub delay: i32,  // Seconds offset for time shifting
}

#[derive(Debug, Clone, serde::Deserialize)]
#[serde(untagged)]
pub enum ReplayOutput {
    Events(Vec<ExpectedOutputType>),
    Error(qwasr_sdk::Error),
}

impl Fixture for Replay {
    type Error = qwasr_sdk::Error;
    type Input = ComponentInputType;
    type Output = Vec<ExpectedOutputType>;
    type TransformParams = ReplayTransform;

    fn from_data(data_def: &TestDef<Self::Error>) -> Self {
        // 1. Parse input (handle XML string -> typed struct if needed)
        let input = data_def.input.as_ref().map(|v| {
            // Adjust parsing based on input format (JSON, XML, etc.)
            serde_json::from_value(v.clone())
                .expect("input should parse to component input type")
        });

        // 2. Parse params
        let params = data_def.params.as_ref().map(|v| {
            serde_json::from_value(v.clone()).expect("params should parse")
        });

        // 3. Parse output - handle TestResult enum
        let output = data_def.output.as_ref().map(|result| match result {
            TestResult::Success(v) => ReplayOutput::Events(
                serde_json::from_value(v.clone()).expect("events should parse")
            ),
            TestResult::Failure(e) => ReplayOutput::Error(e.clone()),
        });

        Self { input, params, output }
    }

    fn input(&self) -> Option<Self::Input> {
        self.input.clone()
    }

    fn params(&self) -> Option<Self::TransformParams> {
        self.params.clone()
    }

    fn output(&self) -> Option<Result<Self::Output, Self::Error>> {
        self.output.as_ref().map(|o| match o {
            ReplayOutput::Events(events) => Ok(events.clone()),
            ReplayOutput::Error(e) => Err(e.clone()),
        })
    }
}

// ============================================
// Mock Provider
// ============================================

#[derive(Clone)]
pub struct MockProvider {
    test_case: PreparedTestCase<Replay>,
    events: Arc<Mutex<Vec<ExpectedOutputType>>>,
}

impl MockProvider {
    pub fn new(test_case: PreparedTestCase<Replay>) -> Self {
        Self {
            test_case,
            events: Arc::new(Mutex::new(Vec::new())),
        }
    }

    pub fn events(&self) -> Vec<ExpectedOutputType> {
        self.events.lock().unwrap().clone()
    }
}

// Config trait - return mock config values
impl Config for MockProvider {
    async fn get(&self, key: &str) -> Result<String> {
        match key {
            "API_URL" => Ok("http://localhost:8080".to_string()),
            "AZURE_IDENTITY" => Ok("mock-identity".to_string()),
            "OUTPUT_TOPIC" => Ok("test-topic".to_string()),
            _ => Err(anyhow!("unknown config key: {key}")),
        }
    }
}

// HttpRequest trait - use Fetcher for mocking
impl HttpRequest for MockProvider {
    async fn fetch<T>(&self, request: http::Request<T>) -> Result<http::Response<bytes::Bytes>>
    where
        T: http_body::Body + std::any::Any + Send + Sync,
        T::Data: Send,
        T::Error: std::error::Error + Send + Sync + 'static,
    {
        let http_requests = self.test_case.http_requests.as_ref()
            .ok_or_else(|| anyhow!("no http_requests defined in fixture"))?;

        let fetcher = Fetcher::new(http_requests);
        fetcher.fetch(&request)
    }
}

// Publisher trait - capture events
impl Publisher for MockProvider {
    async fn send(&self, _topic: &str, message: &Message) -> Result<()> {
        let event: ExpectedOutputType = serde_json::from_slice(&message.payload)
            .context("deserializing published event")?;
        self.events.lock().unwrap().push(event);
        Ok(())
    }
}

// Identity trait - return mock token
impl Identity for MockProvider {
    async fn access_token(&self, _identity: String) -> Result<String> {
        Ok("mock_access_token".to_string())
    }
}

// ============================================
// Time Transformation
// ============================================

/// Adjust timestamps in input to be relative to current time.
/// CRITICAL: This MUST modify timestamps, not just return input unchanged.
pub fn shift_time(
    input: &ComponentInputType,
    params: Option<&ReplayTransform>,
) -> ComponentInputType {
    use chrono::{Utc, Timelike};
    use chrono_tz::Pacific::Auckland;

    let delay = params.map_or(0, |p| p.delay);
    let mut request = input.clone();

    // Get current time
    let now = Utc::now().with_timezone(&Auckland);

    // TODO: Adjust timestamp fields based on component's input structure
    // Example for a message with created_date and time fields:
    //
    // request.created_date = now.date_naive();
    // let from_midnight = now.num_seconds_from_midnight() as i32;
    // let adjusted_secs = from_midnight - delay;
    // request.event_time = adjusted_secs;

    request
}
```

### tests/replay.rs

```rust
use std::fs;
use qwasr_sdk::{api::Client, Error};
use augentic_test::{TestCase, TestDef};
use chrono::{Utc, Timelike};
use chrono_tz::Pacific::Auckland;

mod provider;
use provider::{MockProvider, Replay, shift_time};

#[tokio::test]
async fn run() {
    // CRITICAL: Use correct data path
    let data_dir = std::path::Path::new("data/replay");
    
    if !data_dir.exists() {
        println!("No replay data found at data/replay/, skipping replay tests");
        return;
    }

    for entry in fs::read_dir(data_dir).expect("should read data/replay directory") {
        let path = entry.expect("should read entry").path();
        if path.extension().map_or(false, |e| e == "json") {
            let file = fs::File::open(&path).expect("should open file");
            let test_def: TestDef<Error> = serde_json::from_reader(&file)
                .expect("should parse test definition");

            println!("Running replay: {}", path.display());
            replay(test_def).await;
        }
    }
}

async fn replay(test_def: TestDef<Error>) {
    // 1. Prepare test case with time shifting
    let test_case = TestCase::<Replay>::new(test_def).prepare(shift_time);

    // 2. Create mock provider
    let provider = MockProvider::new(test_case.clone());

    // 3. Use Client abstraction for handler execution
    let client = Client::new("test-owner").provider(provider.clone());

    // 4. Execute handler
    let input = test_case.input.expect("replay test input expected");
    let result = client.request(input).await;

    // 5. Get captured events
    let actual_events = provider.events();

    // 6. Verify based on expected output
    let expected_result = test_case.output.expect("replay test output expected");

    match expected_result {
        Ok(expected_events) => {
            // SUCCESS CASE: Verify events match
            assert_eq!(
                expected_events.len(),
                actual_events.len(),
                "event count mismatch: expected {}, got {}",
                expected_events.len(),
                actual_events.len()
            );

            for (expected, mut actual) in expected_events.into_iter().zip(actual_events) {
                // Check timestamp drift (allow small window)
                let now = Utc::now().with_timezone(&Auckland);
                if let Some(ts) = actual.timestamp() {
                    let diff = now.timestamp() - ts.timestamp();
                    assert!(diff.abs() < 3, "timestamp drift too high: {diff} seconds");
                }

                // Normalize timestamps for equality comparison
                actual.normalize_timestamps(&expected);

                // Deep equality check via JSON
                let json_expected = serde_json::to_value(&expected).unwrap();
                let json_actual = serde_json::to_value(&actual).unwrap();
                assert_eq!(json_expected, json_actual, "event mismatch");
            }
        }
        Err(expected_error) => {
            // ERROR CASE: MUST verify error - do NOT just return Ok(())
            let actual_error = result.expect_err("expected handler to return error");

            assert_eq!(
                actual_error.code(),
                expected_error.code(),
                "error code mismatch: expected '{}', got '{}'",
                expected_error.code(),
                actual_error.code()
            );

            assert_eq!(
                actual_error.description(),
                expected_error.description(),
                "error description mismatch"
            );
        }
    }
}
```

---

## JSON Test Data Schema

Test files in `data/replay/` follow this exact structure:

### Success Case

```json
{
    "input": "<XML>...</XML>",
    "params": { "delay": 120 },
    "http_requests": [
        {
            "path": "/api/data",
            "method": "GET",
            "response": {
                "status": 200,
                "body": ["item1", "item2"]
            }
        }
    ],
    "output": {
        "success": [
            {
                "receivedAt": "2025-01-30T10:00:00Z",
                "eventType": "Location",
                "messageData": { "timestamp": "2025-01-30T10:00:00.000Z" }
            }
        ]
    }
}
```

### Error Case

```json
{
    "input": "<XML>...</XML>",
    "params": { "delay": 506 },
    "output": {
        "failure": {
            "BadRequest": {
                "code": "bad_time",
                "description": "outdated by 506 seconds"
            }
        }
    }
}
```

### Key Points

- `output.success` (lowercase) contains success array
- `output.failure` (lowercase) contains error wrapper
- Error wrapper has variant name (`BadRequest`) with nested `{ code, description }`
- `params.delay` is integer seconds (positive = message is old)
- `http_requests` is optional array of request/response mocks

---

## Provider Trait Checklist

Include these traits based on component usage:

| Trait | When Required |
|-------|---------------|
| `Config` | Always (components read env vars) |
| `HttpRequest` | Component makes HTTP calls - use `Fetcher` |
| `Publisher` | Component publishes messages - capture events |
| `Identity` | ANY HTTP call uses Bearer auth |
| `StateStore` | Component uses caching/state |

---

## Verification Checklist (Mandatory)

### Fixture Implementation

- [ ] Implements `augentic_test::Fixture` trait (not custom struct)
- [ ] All 4 associated types defined: `Error`, `Input`, `Output`, `TransformParams`
- [ ] All 4 trait methods implemented: `from_data`, `input`, `params`, `output`
- [ ] `from_data` handles input format conversion (XML/JSON)

### MockProvider

- [ ] Implements ALL provider traits used by component
- [ ] `Identity` included if ANY HTTP call uses Bearer auth
- [ ] Uses `Fetcher` for HTTP mocking (not manual matching)
- [ ] Captures events in `Arc<Mutex<Vec<_>>>`

### shift_time

- [ ] Accepts TYPED input (not raw string)
- [ ] Actually modifies timestamps (not pass-through)
- [ ] Uses correct timezone
- [ ] Updates relevant time fields based on component logic

### Test Runner

- [ ] Uses `Client::new("owner").provider(...)` abstraction
- [ ] Does NOT call handlers directly
- [ ] Data path is `data/replay/` (not `tests/data/replay/`)

### Error Verification

- [ ] Success cases verify event count AND content
- [ ] Error cases call `expect_err()` and assert code/description
- [ ] NO `Ok(())` returns for error cases without verification

### Imports

- [ ] `augentic_test` in dev-dependencies
- [ ] All imports resolve: `Fetcher`, `Fixture`, `PreparedTestCase`, `TestCase`, `TestDef`
- [ ] `qwasr_sdk::api::Client` imported

---

## Output Summary

Generate these files:

1. `$ARGUMENTS[0]/tests/provider.rs` - Fixture + MockProvider
2. `$ARGUMENTS[0]/tests/replay.rs` - Test runner

Ensure:

- All imports resolve
- Code compiles with `augentic-test`, `qwasr-sdk`, `chrono`
- `shift_time` is properly implemented for component's time logic

---

## Important Notes

- The Replayer tests verify behavior against recorded production data
- Time-shifting is critical for tests with timestamp validation
- MockProvider captures all side-effects for verification
- Error cases must be explicitly verified, not silently passed
- Use `Fetcher` from `augentic_test` for HTTP mocking
